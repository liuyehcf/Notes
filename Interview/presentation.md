

# 语言方面：

Java、C++基础比较扎实。C++方面的话看过STL源码剖析。Java 看过Spring AOP源码，看过JDK concurrent包下部分源码，包括AQS，AQS-ConditionObject，ReentrantLock，ArrayBlockingQueue，ThreadPoolExecutor，ConcurrentHashMap，FutureTask，CountdownLatch，ClicBarrier，Semphore等。对Java虚拟机有一定了解，比如了解运行时内存结构，常规的垃圾收集算法和垃圾收集器以及一些常用的JVM参数，知道Class文件的结构，知道类加载过程，了解JVM对内建锁机制的一个优化。另外熟悉Java内存模型，包括as-if-serial规则，happens-before规则，JVM与顺序一致性模型，锁、volatile，final的内存语意

# 数据结构：

熟悉常用的基本数据结构，对平衡二叉树有一定的研究，包括AVL树、红黑树、B树、B+树都做过实现

# 项目方面：

## 无线视频编码方案

我研究的视频编码方案针对的是无线广播这一场景

广播场景下，面对的是具有不同信道条件的用户群，但是数字编码方式很难做到满足所有用户的需求，因为数字编码方案必须依据信道条件选择特定速率的信源信道编码，因为要让所有用户都能正确解码视频，因此必须以信道质量最差的用户的信道条件为依据来选择编码方案，这样一来，信源编码引入的量化噪声将会非常大，量化噪声的引入是不可逆的，以至于在收端，无论信道条件的好坏，收到的都是同等质量的视频，没有可伸缩性


而模拟编码可以很好的解决这一问题，模拟编码具有很强的伸缩性，随着信道条件的增强，接收视频质量会越来越高，唯一的缺点是在低信噪比时抗噪性能相比于数字方案较差

我们提出了一种方案可以有效地结合这两种编码方案的优点，这种方案就是模拟-数字混合编码方案。

* 首先对每一帧图像进行一个小波变换，得到一个低频分量和3个高频分量。低频分量采用数字编码成bit流然后用高阶QAM调制成整数流，对于数字编码产生的量化噪声以及小波变换得到的三个高频分量，我们采用模拟编码方案，包括2D-DCT变换，压缩和功率分配

* 接下来就是一个传输的问题，如果数字部分与模拟部分分开传输，那么使用的带宽将会扩大一倍，为了避免这样的带宽开销，我们采用了一个的线性叠加方法，直接将数字信号与模拟信号经过功率控制后叠加，那么对于数字信号，模拟信号就是噪声

* 在解码端呢，优先解出数字信号，因为模拟信号对于数字信号而言就是噪声，然后再分离出模拟信号，就能还原出视频序列，该视频序列具有很高的可伸缩性，以及在低信噪比时抗噪性


## LTE-V2X车联网仿真平台

仿真平台模拟街区场景或者高速场景下车辆与车辆之间的通信，统计时延信息以及丢包率等数据

仿真平台从功能上分为三个模块，包括，场景模块，资源管理模块，路由模块。其中场景模块负责车辆的撒点，位置更新，信道刷新，衰落计算等；资源管理模块根据不同的资源分配算法进行时频资源的分配；路由模块根据不同的路由算法进行路由节点的选取


亮点：
1. 在C++基础上实现反射，而且带有一定的侵入性。比如必须继承一个基类object，并且需要使用2-3个预先定义好的宏来进行一个注册操作。
	* 首先要解决的一个问题是，我拿到一个指针，我如何去识别这个指针指向的那个内存地址所代表的类型？我的解决办法是，定义一个基类object，重载operator new操作符和operator delete操作符，这两个操作符用于从堆中分配和释放内存，我额外分配了4个byte用于存放class id，现在内存构造是这样的：首先是class id的内存空间，然后再是基类成员的内存空间
	* 这样一来会产生一个问题，由于子类可能会有虚函数，带有虚函数的子类，其内存构造是这样的：首先是class id的内存地址，紧接着是指向虚函数表的指针，然后是基类成员的内存空间，再是子类成员的内存空间。可以看到，由于虚函数表的指针的存在，基类内存起始地址与class id的起始地址产生了偏移，这个偏移会对class id的提取造成一定的困扰。为了解决这个问题，我给基类定义一个虚函数，这个时候基类的内存构造是这样的：首先是class id的地址，紧接着是虚函数指针，然后是基类成员的内存地址，这样一来，无论子类是否含有额外的虚函数，都不会造成额外的偏移，也就是说基类的起始地址和class id的起始地址之间的偏移量是固定的。这样，我拿到基类的指针，我只要减去4个字节就能得到class id的地址
	* 侵入式体现在必须使用几个宏来进行注册
		* 生成具有同一接口的工厂方法
		* 给每个类生成一个静态的class id
		* 重写operator new operator delete方法，并调用object的operator new方法进行内存分配
		* 对于需要实现反射调用的方法进行注册，即提供一个转型的入口。什么意思呢，我拿到一个基类的指针，指针指向一个子类，我想要调用子类的一个方法，所以我必须把基类的指针强制转型为子类的指针，那么这个强制转型必须出现在代码中，因为类型是编译期的概念。具体的逻辑是什么呢，首先解析出内存中的class id，用if语句查找到匹配的类型，然后进行类型转换，再根据string代表的方法名调用相应的方法。
1. 实现一个IoC容器，根据配置文件初始化单例对象，并进行依赖注入
	* 提供几个配置标签，包括bean，property，dependency，pre-processor和post-processor
	* 初始化顺序是这样的，首先根据配置文件创建出每个单例对象，然后进行依赖注入，然后根据配置的依赖关系，用BFS算法确定bean对象执行初始化方法的顺序，初始化过程到此结束


补充

资源模块
1. 基于地理位置资源管理，区域划分，不同的区域复用时频资源
2. 更多的是基于随机选择算法的一些优化


路由模块
1. 事件的定义，拆分成路由事件以及链路事件
2. TCP(面向连接) 以及 UDP
3. TCP:查找下一跳节点，给路由节点发送sync请求，等待ACK应答。在下一个时钟周期，每个节点将会从sync列表中挑选一个作为来帮助该节点转发消息

## IM聊天软件

这个项目最初的目的是熟悉Java NIO API。

这个项目大致上可以拆分为如下2重要的部分

1. Connection：定义了一系列接口，抽象类以及具体的子类，我重点说一下抽象类
	* 包含一个SocketChannel，并且调成阻塞模式
	* 包含一个MessageReader，和一个MessageWriter，这两个组件作为一个消息中间件。因为，我们只能通过ByteBuffer来从Channel中获取字节信息，这些字节信息是不能够直接使用的。必须依赖于某个协议，我定义了一个Protocol协议，用于规范我的消息格式。MessageReader包含两级缓存，第一级缓存就是内建的ByteBuffer，第二级缓存是可扩容的MessageBuffer，为什么要这个二级缓存，因为一个ByteBuffer可能只包含了部分Message，必须等到一个Message的所有字节到达后才能进行解析。

2. PipeLine：定义了一系列接口，抽象类以及具体的子类
	* 重要的接口方法有，register，以及offLine
	* 抽象类中含有一个ReaderSelector和一个WriterSelector


我看了Spring AOP的源码，Spring分为三部分来实现AOP。收集增强信息，作为interceptor，生成动态代理对象，并且在invoke方法中通过Invocation对象来完成拦截器的增强逻辑的织入。这个Invocation对象是每次方法调用都会new出来的对象，这个对象必须包含方法调用的所有信息，包括Method，对象，以及参数。

我把消息后处理的逻辑代码部分以拦截器的方式进行组织，将这些增强逻辑织入到消息中间件中
1. 定义可以生成动态代理的消息中间件工厂，这个工厂将会生产织入了增强逻辑的消息中间件的代理对象


负载均衡

1. 定义了一个分发器，Dispatcher，对于新产生或者新监听到的Connection进行一个分发
1. 定时进行负载均衡，并且某个线程在进行负载均衡时，其他线程必须停靠在一个全局安全点上(避免在进行复杂均衡时，共享变量的状态发生变化)。可以用ReentrantLock来实现，这个类可以获取当前时刻排队的线程数量



## 尚德机构云外呼平台的开发


外呼平台整体架构分为2大部分：前端业务层和后台管理层

前端业务层主要包含平台管理系统和话务功能接入层，话务能力接入层主要以对外提供JS-SDK的方式实现，平台管理系统则是云外呼管理平台的前台展现。

接入层提供接入服务，包括长连连接服务和短连接入服务。长连接入服务用于和前端业务层数据通信，实现线路切换的功能；短连接入服务则支持前端业务层的其他业务功能。

业务逻辑层封装了4大业务逻辑，包括平台管理，存储话务数据，话单同步和录音同步，是后台提供给接入层调用的API。




# Paxos算法推导

Paxos是一个一致性算法，一致性包含如下几个方面

1. 某个提案必须是某个进程提出的
1. 安全性，即最多只有一个提案会被决议
1. 活性，即总是能达成一致性状态

我们从一个最简单的协议开始，慢慢推导出最终版的paxos协议

协议版本1：每个进程优先会通过它先收到的提案，若形成多数派则该提案被决议

这个协议有个很显然的反例，假设有3个进程，P1，P2，P3，这三个进程各自提出一个提案，那么这个提案首先会被自己通过，于是永远无法形成一个多数派，因此不满足活性。

我们进行如下改进：我们为每个提案增加一个全序增量，基于这个改进的第二版协议如下

协议版本2：每个进程会保存它收到的最大ID，并且如果提案的ID大于保存的ID，那么更新ID并且通过这个提案

我们仍然以P1，P2，P3为例进行说明，假设P1和P2分别提出提案，且P1的ID大于P2的ID

1. 第一种情况：P1的提案先到P3，那么P3更新ID后通过该提案，于是P1的提案被决议。随后P2的提案到达P3，由于P2的ID小于P3保存的ID，于是P3拒绝这个提案，一致性达成
1. 第二种情况：P2的提案先到P3，那么P3更新ID后通过该提案，于是P2的提案被决议。随后P1的提案到达P3，由于P1的ID大于P3保存的ID，于是P3通过该提案，于是P1的提案被决议，因此有两个提案被决议不满足安全性


我们有两种角度来改进

1. P3拒绝P2的提案：P3能够拒绝P2的提案意味着P3在收到P2的提案之前能够获取到某种信息，这种信息能够帮助P3拒绝P2
1. P1提出的提案的值与P2的提案的值相同，那么即便P1的提案被决议，也不会破坏安全性


先从第一个角度来进行改进，我们将提案阶段拆分成预提案阶段和提案阶段。改进后的协议如下

协议版本3：进程在预提案阶段发送提案的ID，当预提案被一个多数派通过后，才能发送提案。每个进程保存它收到的最大ID，当预提案或提案的ID大于保存的ID时，更新ID并通过预提案或提案

针对上面的第二种情况，可以再细分为两种情况

1. 第一种情况：P1的预提案先到P3，那么P3更新ID后通过该预提案，然后P2的提案到达P3，由于P2的ID小于P1的ID，因此P2的提案被拒绝，一致性达成
1. 第二种情况：P2的提案先到，那么P3更新ID后通过该提案，于是P2的提案被决议。这种情况与之前的情况一致

接下来从第二个角度进行改进，在预提案阶段可以提出一个询问，每个通过预提案的进程将返回所有已通过的提案。可以证明，如果预提案形成一个多数派，那么在这些收到的回复中选择一个ID最大的提案，以他的值作为本次提案的值，那么这个值就是最终被决议的提案的值。

下面进行证明：
假设Pj是最终被决议的提案，Pi提出的预提案被一个多数派通过，且回复的提案集合为K-i

首先，提案Pj一定存在于集合K-i中，因为通过Pj提案的多数派与通过Pi预提案的多数派必定存在一个交集，假设为Pa，由于Pa既通过了Pi的预提案又通过了Pj的提案，且Pi的ID大于Pj的ID，那么Pj的提案必定比Pi的预提案先到达Pa，否则Pj的提案会被拒绝，因此Pi提出预提案时，Pj的提案一定包含在Pa的回复中

假设存在一个策略cf，这个策略cf使得总能从K-i中选出最终被决议的提案的值

要证明的是当Pm.v!=Pj.v，那么Pm.ID必然小于Pj.ID

采用反证法，假设Pm.ID > Pj.ID，由于Pm的提案已经被提出，因此在预提案阶段存在一个多数派通过Pm的预提案，且存在另一个多数派通过Pj的提案，因此这两个多数派存在一个交集Ps，即Ps既通过了Pm的预提案，又通过了Pj的提案，Pm的预提案与Pj的提案到达Ps的顺序有以下两种

1. Pm的预提案先到Ps，那么根据协议，Ps将拒绝Pj的提案，矛盾
1. Pj的提案先到Ps，那么根据策略cf，Pm提案的值将等于v，矛盾

因此Pm.ID<Pj.ID