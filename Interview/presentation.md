

# 语言方面：

Java、C++基础比较扎实。C++方面的话看过STL源码。Java 看过Spring AOP源码，看过JDK concurrent包下部分源码，包括AQS，ConditionObject，ReentrantLock，ArrayBlockingQueue，ConcurrentHashMap，ThreadPoolExecutor，FutureTask等。对Java虚拟机有一定了解，比如了解运行时内存结构，常规的垃圾收集机制以及一些常用的JVM参数，知道Class文件的结构，知道类加载过程，JVM对内建锁机制的一个优化。另外熟悉Java内存模型，包括as-if-serial规则，happens-before规则，JVM与顺序一致性模型，锁、volatile，final的内存语意

# 数据结构：

熟悉常用的基本数据结构，对平衡二叉树有一定的研究，包括AVL树、红黑树、B树、B+树都做过实现

# 项目方面：

## 无线视频编码方案

我研究的视频编码方案针对的是无线广播这一场景

广播场景下，面对的是具有不同信道条件的用户群，但是数字编码方式很难做到满足所有用户的需求，
因为数字编码必须依据信道条件选择一种信源信道编码，因为要让所有用户都能观看视频，因此必须以信道质量最差的用户的信道条件为依据来选择编码方案，这样一来，信源编码引入的量化噪声将会非常大，量化噪声的引入是不可逆的，以至于在收端，无论信道条件的好坏，收到的都是同等质量的视频，没有可伸缩性


而模拟编码可以很好的解决这一问题，模拟编码具有很强的伸缩性，PSNR曲线是一条直线，唯一的缺点是低信噪比时抗噪性能相比于数字方案较差

我们提出了一种方案可以有效地结合这两种编码方案的优点，这种方案就是模拟-数字混合编码方案。

首先对每一帧图像进行一个小波变换，得到一个低频分量和3个高频分量。低频分量采用数字编码成bit流然后用高阶QAM调制成整数流，对于数字编码产生的量化噪声以及小波变换得到的三个高频分量，我们采用模拟编码方案

接下来就是一个传输的问题，如果数字部分与模拟部分分开传输，那么使用的带宽将会扩大一倍，为了避免这样的带宽开销，我们采用了一个的线性叠加方法，直接将数字信号与模拟信号经过功率控制后叠加，那么对于低频分量，高频分量就是噪声。

在解码端呢，只需要分别解出高低频分量，就能还原出视频序列，该视频序列具有很高的可伸缩性


## LTE-V2X车联网仿真平台

在仿真平台模拟街区场景或者高速场景下车辆与车辆之间的通信，统计时延信息以及丢包率等数据

功能模块包括，场景模块，资源管理模块，路由模块。其中场景模块包括车辆的撒点，位置更新，信道刷新，衰落计算等；资源管理模块负责时频资源的分配；路由模块根据不同的路由算法进行路由节点的选取

资源模块
1. 基于地理位置资源管理，区域划分，不同的区域复用时频资源
2. 更多的是基于随机选择算法的一些优化


路由模块
1. 事件的定义，拆分成路由事件以及链路事件
2. TCP(面向连接) 以及 UDP
3. TCP:查找下一跳节点，给路由节点发送sync请求，等待ACK应答。在下一个时钟周期，每个节点将会从sync列表中挑选一个作为来帮助该节点转发消息


亮点：
1. 在C++基础上实现反射，而且带有一定的侵入性。比如必须继承一个基类object，并且需要使用2-3个预先定义好的宏来进行一个注册操作。
	* 首先要解决的一个问题是，我拿到一个指针，我如何去识别这个指针指向的那个内存块所代表的类型？我的解决办法是，定义一个基类object，这个基类重载operator new操作符，这个操作符用于从堆中分配一块未初始化的内存，在分配内存的开头再增加一个32位的内存来存放一个id，用于标志这个类的真实类型。
	* 第二个问题是，由于子类可能会有虚函数，带有虚函数的子类，其内存构造是这样的：首先是32位的class id，紧接着是指向虚函数表的指针，然后是基类内存，再是子类内存。可以看到，由于虚函数表的指针的存在，基类内存起始地址与class id的起始地址产生了偏移，这个偏移会对class id的提取造成一定的困扰。为了解决这个问题，给基类定义一个虚函数，那么基类的起始内存就是虚函数的地址，这样一来，无论子类是否含有额外的虚函数，都不会造成额外的偏移。这样我就能通过一个统一的偏移量去读取class id
	* 侵入式体现在必须使用几个宏来进行注册
		* 生成具有同一接口的工厂方法
		* 给每个类生成一个静态的class id
		* 重写operator new operator delete方法，并调用object的operator new方法进行内存分配
		* 对需要实现反射的方法进行注册，即提供一个转型的入口。什么意思呢，我拿到一个基类的指针，我想要调用子类的一个方法，但是这个方法基类是没有的，我只能把它强制转型为子类才能进行调用，那么这个强制转型必须出现在代码中，因为类型是编译期的概念。具体的逻辑是什么呢，每个类有一个静态常量标记了这个类的class id，解析出指针指向内存的class id，找到匹配的类型，进行转型，然后根据string所指示的方法调用对应的方法。
1. 实现一个IoC容器，根据配置文件初始化单例对象，并进行依赖注入
	* 提供几个配置标签，包括bean，property，dependency，pre-processor和post-processor
	* 根据配置的依赖关系，用BFS算法确定bean对象的初始化顺序，并调用相应的初始化方法，完成单例对象的初始化



## IM聊天软件

这个项目最初的目的是熟悉Java NIO API。

这个项目大致上可以拆分为如下2重要的继承体系

1. Connection：定义了一系列接口，抽象类以及具体的子类，我重点说一下抽象类
	* 包含一个SocketChannel，并且调成阻塞模式
	* 包含一个MessageReader，和一个MessageWriter，这两个组件作为一个消息中间件。因为，我们只能通过ByteBuffer来从Channel中获取字节信息，这些字节信息是不能够直接使用的。必须依赖于某个协议，我定义了一个Protocol协议，用于规范我的消息格式。MessageReader包含两级缓存，第一级缓存就是内建的ByteBuffer，第二级缓存是可扩容的MessageBuffer，为什么要这个二级缓存，因为一个ByteBuffer可能只包含了部分Message，必须等到一个Message的所有字节到达后才能进行解析。

2. PipeLine：定义了一系列接口，抽象类以及具体的子类
	* 重要的接口方法有，register，以及offLine
	* 抽象类中含有一个ReaderSelector和一个WriterSelector


我看了Spring AOP的源码，Spring分为三部分来实现AOP。收集增强信息，作为interceptor，生成动态代理对象，并且在invoke方法中通过Invocation对象来完成拦截器的增强逻辑的织入。这个Invocation对象是每次方法调用都会new出来的对象，这个对象必须包含方法调用的所有信息，包括Method，对象，以及参数。

我把消息后处理的逻辑代码部分以拦截器的方式进行组织，将这些增强逻辑织入到消息中间件中
1. 定义可以生成动态代理的消息中间件工厂，这个工厂将会生产织入了增强逻辑的消息中间件的代理对象


负载均衡

1. 定义了一个分发器，Dispatcher，对于新产生或者新监听到的Connection进行一个分发
1. 定时进行负载均衡，并且某个线程在进行负载均衡时，其他线程必须停靠在一个全局安全点上(避免在进行复杂均衡时，共享变量的状态发生变化)。可以用ReentrantLock来实现，这个类可以获取当前时刻排队的线程数量



## 尚德机构云外呼平台的开发


